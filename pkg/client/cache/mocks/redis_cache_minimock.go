// Code generated by http://github.com/gojuno/minimock (v3.4.2). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/kms-qwe/platform_common/pkg/client/cache.RedisCache -o redis_cache_minimock.go -n RedisCacheMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RedisCacheMock implements cache.RedisCache
type RedisCacheMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcExpire          func(ctx context.Context, key string, expirationTime time.Duration) (err error)
	inspectFuncExpire   func(ctx context.Context, key string, expirationTime time.Duration)
	afterExpireCounter  uint64
	beforeExpireCounter uint64
	ExpireMock          mRedisCacheMockExpire

	funcGet          func(ctx context.Context, key string) (p1 interface{}, err error)
	inspectFuncGet   func(ctx context.Context, key string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mRedisCacheMockGet

	funcHGetAll          func(ctx context.Context, key string) (pa1 []interface{}, err error)
	inspectFuncHGetAll   func(ctx context.Context, key string)
	afterHGetAllCounter  uint64
	beforeHGetAllCounter uint64
	HGetAllMock          mRedisCacheMockHGetAll

	funcHashSet          func(ctx context.Context, key string, value interface{}) (err error)
	inspectFuncHashSet   func(ctx context.Context, key string, value interface{})
	afterHashSetCounter  uint64
	beforeHashSetCounter uint64
	HashSetMock          mRedisCacheMockHashSet

	funcPing          func(ctx context.Context) (err error)
	inspectFuncPing   func(ctx context.Context)
	afterPingCounter  uint64
	beforePingCounter uint64
	PingMock          mRedisCacheMockPing

	funcSet          func(ctx context.Context, key string, value interface{}) (err error)
	inspectFuncSet   func(ctx context.Context, key string, value interface{})
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mRedisCacheMockSet
}

// NewRedisCacheMock returns a mock for cache.RedisCache
func NewRedisCacheMock(t minimock.Tester) *RedisCacheMock {
	m := &RedisCacheMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExpireMock = mRedisCacheMockExpire{mock: m}
	m.ExpireMock.callArgs = []*RedisCacheMockExpireParams{}

	m.GetMock = mRedisCacheMockGet{mock: m}
	m.GetMock.callArgs = []*RedisCacheMockGetParams{}

	m.HGetAllMock = mRedisCacheMockHGetAll{mock: m}
	m.HGetAllMock.callArgs = []*RedisCacheMockHGetAllParams{}

	m.HashSetMock = mRedisCacheMockHashSet{mock: m}
	m.HashSetMock.callArgs = []*RedisCacheMockHashSetParams{}

	m.PingMock = mRedisCacheMockPing{mock: m}
	m.PingMock.callArgs = []*RedisCacheMockPingParams{}

	m.SetMock = mRedisCacheMockSet{mock: m}
	m.SetMock.callArgs = []*RedisCacheMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRedisCacheMockExpire struct {
	optional           bool
	mock               *RedisCacheMock
	defaultExpectation *RedisCacheMockExpireExpectation
	expectations       []*RedisCacheMockExpireExpectation

	callArgs []*RedisCacheMockExpireParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RedisCacheMockExpireExpectation specifies expectation struct of the RedisCache.Expire
type RedisCacheMockExpireExpectation struct {
	mock      *RedisCacheMock
	params    *RedisCacheMockExpireParams
	paramPtrs *RedisCacheMockExpireParamPtrs
	results   *RedisCacheMockExpireResults
	Counter   uint64
}

// RedisCacheMockExpireParams contains parameters of the RedisCache.Expire
type RedisCacheMockExpireParams struct {
	ctx            context.Context
	key            string
	expirationTime time.Duration
}

// RedisCacheMockExpireParamPtrs contains pointers to parameters of the RedisCache.Expire
type RedisCacheMockExpireParamPtrs struct {
	ctx            *context.Context
	key            *string
	expirationTime *time.Duration
}

// RedisCacheMockExpireResults contains results of the RedisCache.Expire
type RedisCacheMockExpireResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExpire *mRedisCacheMockExpire) Optional() *mRedisCacheMockExpire {
	mmExpire.optional = true
	return mmExpire
}

// Expect sets up expected params for RedisCache.Expire
func (mmExpire *mRedisCacheMockExpire) Expect(ctx context.Context, key string, expirationTime time.Duration) *mRedisCacheMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RedisCacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RedisCacheMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.paramPtrs != nil {
		mmExpire.mock.t.Fatalf("RedisCacheMock.Expire mock is already set by ExpectParams functions")
	}

	mmExpire.defaultExpectation.params = &RedisCacheMockExpireParams{ctx, key, expirationTime}
	for _, e := range mmExpire.expectations {
		if minimock.Equal(e.params, mmExpire.defaultExpectation.params) {
			mmExpire.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExpire.defaultExpectation.params)
		}
	}

	return mmExpire
}

// ExpectCtxParam1 sets up expected param ctx for RedisCache.Expire
func (mmExpire *mRedisCacheMockExpire) ExpectCtxParam1(ctx context.Context) *mRedisCacheMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RedisCacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RedisCacheMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("RedisCacheMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &RedisCacheMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.ctx = &ctx

	return mmExpire
}

// ExpectKeyParam2 sets up expected param key for RedisCache.Expire
func (mmExpire *mRedisCacheMockExpire) ExpectKeyParam2(key string) *mRedisCacheMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RedisCacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RedisCacheMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("RedisCacheMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &RedisCacheMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.key = &key

	return mmExpire
}

// ExpectExpirationTimeParam3 sets up expected param expirationTime for RedisCache.Expire
func (mmExpire *mRedisCacheMockExpire) ExpectExpirationTimeParam3(expirationTime time.Duration) *mRedisCacheMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RedisCacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RedisCacheMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("RedisCacheMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &RedisCacheMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.expirationTime = &expirationTime

	return mmExpire
}

// Inspect accepts an inspector function that has same arguments as the RedisCache.Expire
func (mmExpire *mRedisCacheMockExpire) Inspect(f func(ctx context.Context, key string, expirationTime time.Duration)) *mRedisCacheMockExpire {
	if mmExpire.mock.inspectFuncExpire != nil {
		mmExpire.mock.t.Fatalf("Inspect function is already set for RedisCacheMock.Expire")
	}

	mmExpire.mock.inspectFuncExpire = f

	return mmExpire
}

// Return sets up results that will be returned by RedisCache.Expire
func (mmExpire *mRedisCacheMockExpire) Return(err error) *RedisCacheMock {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RedisCacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &RedisCacheMockExpireExpectation{mock: mmExpire.mock}
	}
	mmExpire.defaultExpectation.results = &RedisCacheMockExpireResults{err}
	return mmExpire.mock
}

// Set uses given function f to mock the RedisCache.Expire method
func (mmExpire *mRedisCacheMockExpire) Set(f func(ctx context.Context, key string, expirationTime time.Duration) (err error)) *RedisCacheMock {
	if mmExpire.defaultExpectation != nil {
		mmExpire.mock.t.Fatalf("Default expectation is already set for the RedisCache.Expire method")
	}

	if len(mmExpire.expectations) > 0 {
		mmExpire.mock.t.Fatalf("Some expectations are already set for the RedisCache.Expire method")
	}

	mmExpire.mock.funcExpire = f
	return mmExpire.mock
}

// When sets expectation for the RedisCache.Expire which will trigger the result defined by the following
// Then helper
func (mmExpire *mRedisCacheMockExpire) When(ctx context.Context, key string, expirationTime time.Duration) *RedisCacheMockExpireExpectation {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("RedisCacheMock.Expire mock is already set by Set")
	}

	expectation := &RedisCacheMockExpireExpectation{
		mock:   mmExpire.mock,
		params: &RedisCacheMockExpireParams{ctx, key, expirationTime},
	}
	mmExpire.expectations = append(mmExpire.expectations, expectation)
	return expectation
}

// Then sets up RedisCache.Expire return parameters for the expectation previously defined by the When method
func (e *RedisCacheMockExpireExpectation) Then(err error) *RedisCacheMock {
	e.results = &RedisCacheMockExpireResults{err}
	return e.mock
}

// Times sets number of times RedisCache.Expire should be invoked
func (mmExpire *mRedisCacheMockExpire) Times(n uint64) *mRedisCacheMockExpire {
	if n == 0 {
		mmExpire.mock.t.Fatalf("Times of RedisCacheMock.Expire mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExpire.expectedInvocations, n)
	return mmExpire
}

func (mmExpire *mRedisCacheMockExpire) invocationsDone() bool {
	if len(mmExpire.expectations) == 0 && mmExpire.defaultExpectation == nil && mmExpire.mock.funcExpire == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExpire.mock.afterExpireCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExpire.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Expire implements cache.RedisCache
func (mmExpire *RedisCacheMock) Expire(ctx context.Context, key string, expirationTime time.Duration) (err error) {
	mm_atomic.AddUint64(&mmExpire.beforeExpireCounter, 1)
	defer mm_atomic.AddUint64(&mmExpire.afterExpireCounter, 1)

	if mmExpire.inspectFuncExpire != nil {
		mmExpire.inspectFuncExpire(ctx, key, expirationTime)
	}

	mm_params := RedisCacheMockExpireParams{ctx, key, expirationTime}

	// Record call args
	mmExpire.ExpireMock.mutex.Lock()
	mmExpire.ExpireMock.callArgs = append(mmExpire.ExpireMock.callArgs, &mm_params)
	mmExpire.ExpireMock.mutex.Unlock()

	for _, e := range mmExpire.ExpireMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmExpire.ExpireMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExpire.ExpireMock.defaultExpectation.Counter, 1)
		mm_want := mmExpire.ExpireMock.defaultExpectation.params
		mm_want_ptrs := mmExpire.ExpireMock.defaultExpectation.paramPtrs

		mm_got := RedisCacheMockExpireParams{ctx, key, expirationTime}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExpire.t.Errorf("RedisCacheMock.Expire got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmExpire.t.Errorf("RedisCacheMock.Expire got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.expirationTime != nil && !minimock.Equal(*mm_want_ptrs.expirationTime, mm_got.expirationTime) {
				mmExpire.t.Errorf("RedisCacheMock.Expire got unexpected parameter expirationTime, want: %#v, got: %#v%s\n", *mm_want_ptrs.expirationTime, mm_got.expirationTime, minimock.Diff(*mm_want_ptrs.expirationTime, mm_got.expirationTime))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExpire.t.Errorf("RedisCacheMock.Expire got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExpire.ExpireMock.defaultExpectation.results
		if mm_results == nil {
			mmExpire.t.Fatal("No results are set for the RedisCacheMock.Expire")
		}
		return (*mm_results).err
	}
	if mmExpire.funcExpire != nil {
		return mmExpire.funcExpire(ctx, key, expirationTime)
	}
	mmExpire.t.Fatalf("Unexpected call to RedisCacheMock.Expire. %v %v %v", ctx, key, expirationTime)
	return
}

// ExpireAfterCounter returns a count of finished RedisCacheMock.Expire invocations
func (mmExpire *RedisCacheMock) ExpireAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.afterExpireCounter)
}

// ExpireBeforeCounter returns a count of RedisCacheMock.Expire invocations
func (mmExpire *RedisCacheMock) ExpireBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.beforeExpireCounter)
}

// Calls returns a list of arguments used in each call to RedisCacheMock.Expire.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExpire *mRedisCacheMockExpire) Calls() []*RedisCacheMockExpireParams {
	mmExpire.mutex.RLock()

	argCopy := make([]*RedisCacheMockExpireParams, len(mmExpire.callArgs))
	copy(argCopy, mmExpire.callArgs)

	mmExpire.mutex.RUnlock()

	return argCopy
}

// MinimockExpireDone returns true if the count of the Expire invocations corresponds
// the number of defined expectations
func (m *RedisCacheMock) MinimockExpireDone() bool {
	if m.ExpireMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExpireMock.invocationsDone()
}

// MinimockExpireInspect logs each unmet expectation
func (m *RedisCacheMock) MinimockExpireInspect() {
	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisCacheMock.Expire with params: %#v", *e.params)
		}
	}

	afterExpireCounter := mm_atomic.LoadUint64(&m.afterExpireCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExpireMock.defaultExpectation != nil && afterExpireCounter < 1 {
		if m.ExpireMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RedisCacheMock.Expire")
		} else {
			m.t.Errorf("Expected call to RedisCacheMock.Expire with params: %#v", *m.ExpireMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExpire != nil && afterExpireCounter < 1 {
		m.t.Error("Expected call to RedisCacheMock.Expire")
	}

	if !m.ExpireMock.invocationsDone() && afterExpireCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCacheMock.Expire but found %d calls",
			mm_atomic.LoadUint64(&m.ExpireMock.expectedInvocations), afterExpireCounter)
	}
}

type mRedisCacheMockGet struct {
	optional           bool
	mock               *RedisCacheMock
	defaultExpectation *RedisCacheMockGetExpectation
	expectations       []*RedisCacheMockGetExpectation

	callArgs []*RedisCacheMockGetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RedisCacheMockGetExpectation specifies expectation struct of the RedisCache.Get
type RedisCacheMockGetExpectation struct {
	mock      *RedisCacheMock
	params    *RedisCacheMockGetParams
	paramPtrs *RedisCacheMockGetParamPtrs
	results   *RedisCacheMockGetResults
	Counter   uint64
}

// RedisCacheMockGetParams contains parameters of the RedisCache.Get
type RedisCacheMockGetParams struct {
	ctx context.Context
	key string
}

// RedisCacheMockGetParamPtrs contains pointers to parameters of the RedisCache.Get
type RedisCacheMockGetParamPtrs struct {
	ctx *context.Context
	key *string
}

// RedisCacheMockGetResults contains results of the RedisCache.Get
type RedisCacheMockGetResults struct {
	p1  interface{}
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mRedisCacheMockGet) Optional() *mRedisCacheMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for RedisCache.Get
func (mmGet *mRedisCacheMockGet) Expect(ctx context.Context, key string) *mRedisCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisCacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisCacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("RedisCacheMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &RedisCacheMockGetParams{ctx, key}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for RedisCache.Get
func (mmGet *mRedisCacheMockGet) ExpectCtxParam1(ctx context.Context) *mRedisCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisCacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisCacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("RedisCacheMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &RedisCacheMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGet
}

// ExpectKeyParam2 sets up expected param key for RedisCache.Get
func (mmGet *mRedisCacheMockGet) ExpectKeyParam2(key string) *mRedisCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisCacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisCacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("RedisCacheMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &RedisCacheMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.key = &key

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the RedisCache.Get
func (mmGet *mRedisCacheMockGet) Inspect(f func(ctx context.Context, key string)) *mRedisCacheMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for RedisCacheMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by RedisCache.Get
func (mmGet *mRedisCacheMockGet) Return(p1 interface{}, err error) *RedisCacheMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisCacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RedisCacheMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &RedisCacheMockGetResults{p1, err}
	return mmGet.mock
}

// Set uses given function f to mock the RedisCache.Get method
func (mmGet *mRedisCacheMockGet) Set(f func(ctx context.Context, key string) (p1 interface{}, err error)) *RedisCacheMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the RedisCache.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the RedisCache.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the RedisCache.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mRedisCacheMockGet) When(ctx context.Context, key string) *RedisCacheMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RedisCacheMock.Get mock is already set by Set")
	}

	expectation := &RedisCacheMockGetExpectation{
		mock:   mmGet.mock,
		params: &RedisCacheMockGetParams{ctx, key},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up RedisCache.Get return parameters for the expectation previously defined by the When method
func (e *RedisCacheMockGetExpectation) Then(p1 interface{}, err error) *RedisCacheMock {
	e.results = &RedisCacheMockGetResults{p1, err}
	return e.mock
}

// Times sets number of times RedisCache.Get should be invoked
func (mmGet *mRedisCacheMockGet) Times(n uint64) *mRedisCacheMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of RedisCacheMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	return mmGet
}

func (mmGet *mRedisCacheMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements cache.RedisCache
func (mmGet *RedisCacheMock) Get(ctx context.Context, key string) (p1 interface{}, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, key)
	}

	mm_params := RedisCacheMockGetParams{ctx, key}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := RedisCacheMockGetParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("RedisCacheMock.Get got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGet.t.Errorf("RedisCacheMock.Get got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("RedisCacheMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the RedisCacheMock.Get")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, key)
	}
	mmGet.t.Fatalf("Unexpected call to RedisCacheMock.Get. %v %v", ctx, key)
	return
}

// GetAfterCounter returns a count of finished RedisCacheMock.Get invocations
func (mmGet *RedisCacheMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of RedisCacheMock.Get invocations
func (mmGet *RedisCacheMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to RedisCacheMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mRedisCacheMockGet) Calls() []*RedisCacheMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*RedisCacheMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *RedisCacheMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *RedisCacheMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisCacheMock.Get with params: %#v", *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RedisCacheMock.Get")
		} else {
			m.t.Errorf("Expected call to RedisCacheMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Error("Expected call to RedisCacheMock.Get")
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCacheMock.Get but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), afterGetCounter)
	}
}

type mRedisCacheMockHGetAll struct {
	optional           bool
	mock               *RedisCacheMock
	defaultExpectation *RedisCacheMockHGetAllExpectation
	expectations       []*RedisCacheMockHGetAllExpectation

	callArgs []*RedisCacheMockHGetAllParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RedisCacheMockHGetAllExpectation specifies expectation struct of the RedisCache.HGetAll
type RedisCacheMockHGetAllExpectation struct {
	mock      *RedisCacheMock
	params    *RedisCacheMockHGetAllParams
	paramPtrs *RedisCacheMockHGetAllParamPtrs
	results   *RedisCacheMockHGetAllResults
	Counter   uint64
}

// RedisCacheMockHGetAllParams contains parameters of the RedisCache.HGetAll
type RedisCacheMockHGetAllParams struct {
	ctx context.Context
	key string
}

// RedisCacheMockHGetAllParamPtrs contains pointers to parameters of the RedisCache.HGetAll
type RedisCacheMockHGetAllParamPtrs struct {
	ctx *context.Context
	key *string
}

// RedisCacheMockHGetAllResults contains results of the RedisCache.HGetAll
type RedisCacheMockHGetAllResults struct {
	pa1 []interface{}
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHGetAll *mRedisCacheMockHGetAll) Optional() *mRedisCacheMockHGetAll {
	mmHGetAll.optional = true
	return mmHGetAll
}

// Expect sets up expected params for RedisCache.HGetAll
func (mmHGetAll *mRedisCacheMockHGetAll) Expect(ctx context.Context, key string) *mRedisCacheMockHGetAll {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("RedisCacheMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &RedisCacheMockHGetAllExpectation{}
	}

	if mmHGetAll.defaultExpectation.paramPtrs != nil {
		mmHGetAll.mock.t.Fatalf("RedisCacheMock.HGetAll mock is already set by ExpectParams functions")
	}

	mmHGetAll.defaultExpectation.params = &RedisCacheMockHGetAllParams{ctx, key}
	for _, e := range mmHGetAll.expectations {
		if minimock.Equal(e.params, mmHGetAll.defaultExpectation.params) {
			mmHGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHGetAll.defaultExpectation.params)
		}
	}

	return mmHGetAll
}

// ExpectCtxParam1 sets up expected param ctx for RedisCache.HGetAll
func (mmHGetAll *mRedisCacheMockHGetAll) ExpectCtxParam1(ctx context.Context) *mRedisCacheMockHGetAll {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("RedisCacheMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &RedisCacheMockHGetAllExpectation{}
	}

	if mmHGetAll.defaultExpectation.params != nil {
		mmHGetAll.mock.t.Fatalf("RedisCacheMock.HGetAll mock is already set by Expect")
	}

	if mmHGetAll.defaultExpectation.paramPtrs == nil {
		mmHGetAll.defaultExpectation.paramPtrs = &RedisCacheMockHGetAllParamPtrs{}
	}
	mmHGetAll.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHGetAll
}

// ExpectKeyParam2 sets up expected param key for RedisCache.HGetAll
func (mmHGetAll *mRedisCacheMockHGetAll) ExpectKeyParam2(key string) *mRedisCacheMockHGetAll {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("RedisCacheMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &RedisCacheMockHGetAllExpectation{}
	}

	if mmHGetAll.defaultExpectation.params != nil {
		mmHGetAll.mock.t.Fatalf("RedisCacheMock.HGetAll mock is already set by Expect")
	}

	if mmHGetAll.defaultExpectation.paramPtrs == nil {
		mmHGetAll.defaultExpectation.paramPtrs = &RedisCacheMockHGetAllParamPtrs{}
	}
	mmHGetAll.defaultExpectation.paramPtrs.key = &key

	return mmHGetAll
}

// Inspect accepts an inspector function that has same arguments as the RedisCache.HGetAll
func (mmHGetAll *mRedisCacheMockHGetAll) Inspect(f func(ctx context.Context, key string)) *mRedisCacheMockHGetAll {
	if mmHGetAll.mock.inspectFuncHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("Inspect function is already set for RedisCacheMock.HGetAll")
	}

	mmHGetAll.mock.inspectFuncHGetAll = f

	return mmHGetAll
}

// Return sets up results that will be returned by RedisCache.HGetAll
func (mmHGetAll *mRedisCacheMockHGetAll) Return(pa1 []interface{}, err error) *RedisCacheMock {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("RedisCacheMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &RedisCacheMockHGetAllExpectation{mock: mmHGetAll.mock}
	}
	mmHGetAll.defaultExpectation.results = &RedisCacheMockHGetAllResults{pa1, err}
	return mmHGetAll.mock
}

// Set uses given function f to mock the RedisCache.HGetAll method
func (mmHGetAll *mRedisCacheMockHGetAll) Set(f func(ctx context.Context, key string) (pa1 []interface{}, err error)) *RedisCacheMock {
	if mmHGetAll.defaultExpectation != nil {
		mmHGetAll.mock.t.Fatalf("Default expectation is already set for the RedisCache.HGetAll method")
	}

	if len(mmHGetAll.expectations) > 0 {
		mmHGetAll.mock.t.Fatalf("Some expectations are already set for the RedisCache.HGetAll method")
	}

	mmHGetAll.mock.funcHGetAll = f
	return mmHGetAll.mock
}

// When sets expectation for the RedisCache.HGetAll which will trigger the result defined by the following
// Then helper
func (mmHGetAll *mRedisCacheMockHGetAll) When(ctx context.Context, key string) *RedisCacheMockHGetAllExpectation {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("RedisCacheMock.HGetAll mock is already set by Set")
	}

	expectation := &RedisCacheMockHGetAllExpectation{
		mock:   mmHGetAll.mock,
		params: &RedisCacheMockHGetAllParams{ctx, key},
	}
	mmHGetAll.expectations = append(mmHGetAll.expectations, expectation)
	return expectation
}

// Then sets up RedisCache.HGetAll return parameters for the expectation previously defined by the When method
func (e *RedisCacheMockHGetAllExpectation) Then(pa1 []interface{}, err error) *RedisCacheMock {
	e.results = &RedisCacheMockHGetAllResults{pa1, err}
	return e.mock
}

// Times sets number of times RedisCache.HGetAll should be invoked
func (mmHGetAll *mRedisCacheMockHGetAll) Times(n uint64) *mRedisCacheMockHGetAll {
	if n == 0 {
		mmHGetAll.mock.t.Fatalf("Times of RedisCacheMock.HGetAll mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHGetAll.expectedInvocations, n)
	return mmHGetAll
}

func (mmHGetAll *mRedisCacheMockHGetAll) invocationsDone() bool {
	if len(mmHGetAll.expectations) == 0 && mmHGetAll.defaultExpectation == nil && mmHGetAll.mock.funcHGetAll == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHGetAll.mock.afterHGetAllCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHGetAll.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HGetAll implements cache.RedisCache
func (mmHGetAll *RedisCacheMock) HGetAll(ctx context.Context, key string) (pa1 []interface{}, err error) {
	mm_atomic.AddUint64(&mmHGetAll.beforeHGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmHGetAll.afterHGetAllCounter, 1)

	if mmHGetAll.inspectFuncHGetAll != nil {
		mmHGetAll.inspectFuncHGetAll(ctx, key)
	}

	mm_params := RedisCacheMockHGetAllParams{ctx, key}

	// Record call args
	mmHGetAll.HGetAllMock.mutex.Lock()
	mmHGetAll.HGetAllMock.callArgs = append(mmHGetAll.HGetAllMock.callArgs, &mm_params)
	mmHGetAll.HGetAllMock.mutex.Unlock()

	for _, e := range mmHGetAll.HGetAllMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmHGetAll.HGetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHGetAll.HGetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmHGetAll.HGetAllMock.defaultExpectation.params
		mm_want_ptrs := mmHGetAll.HGetAllMock.defaultExpectation.paramPtrs

		mm_got := RedisCacheMockHGetAllParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHGetAll.t.Errorf("RedisCacheMock.HGetAll got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmHGetAll.t.Errorf("RedisCacheMock.HGetAll got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHGetAll.t.Errorf("RedisCacheMock.HGetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHGetAll.HGetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmHGetAll.t.Fatal("No results are set for the RedisCacheMock.HGetAll")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmHGetAll.funcHGetAll != nil {
		return mmHGetAll.funcHGetAll(ctx, key)
	}
	mmHGetAll.t.Fatalf("Unexpected call to RedisCacheMock.HGetAll. %v %v", ctx, key)
	return
}

// HGetAllAfterCounter returns a count of finished RedisCacheMock.HGetAll invocations
func (mmHGetAll *RedisCacheMock) HGetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHGetAll.afterHGetAllCounter)
}

// HGetAllBeforeCounter returns a count of RedisCacheMock.HGetAll invocations
func (mmHGetAll *RedisCacheMock) HGetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHGetAll.beforeHGetAllCounter)
}

// Calls returns a list of arguments used in each call to RedisCacheMock.HGetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHGetAll *mRedisCacheMockHGetAll) Calls() []*RedisCacheMockHGetAllParams {
	mmHGetAll.mutex.RLock()

	argCopy := make([]*RedisCacheMockHGetAllParams, len(mmHGetAll.callArgs))
	copy(argCopy, mmHGetAll.callArgs)

	mmHGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockHGetAllDone returns true if the count of the HGetAll invocations corresponds
// the number of defined expectations
func (m *RedisCacheMock) MinimockHGetAllDone() bool {
	if m.HGetAllMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HGetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HGetAllMock.invocationsDone()
}

// MinimockHGetAllInspect logs each unmet expectation
func (m *RedisCacheMock) MinimockHGetAllInspect() {
	for _, e := range m.HGetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisCacheMock.HGetAll with params: %#v", *e.params)
		}
	}

	afterHGetAllCounter := mm_atomic.LoadUint64(&m.afterHGetAllCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HGetAllMock.defaultExpectation != nil && afterHGetAllCounter < 1 {
		if m.HGetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RedisCacheMock.HGetAll")
		} else {
			m.t.Errorf("Expected call to RedisCacheMock.HGetAll with params: %#v", *m.HGetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHGetAll != nil && afterHGetAllCounter < 1 {
		m.t.Error("Expected call to RedisCacheMock.HGetAll")
	}

	if !m.HGetAllMock.invocationsDone() && afterHGetAllCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCacheMock.HGetAll but found %d calls",
			mm_atomic.LoadUint64(&m.HGetAllMock.expectedInvocations), afterHGetAllCounter)
	}
}

type mRedisCacheMockHashSet struct {
	optional           bool
	mock               *RedisCacheMock
	defaultExpectation *RedisCacheMockHashSetExpectation
	expectations       []*RedisCacheMockHashSetExpectation

	callArgs []*RedisCacheMockHashSetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RedisCacheMockHashSetExpectation specifies expectation struct of the RedisCache.HashSet
type RedisCacheMockHashSetExpectation struct {
	mock      *RedisCacheMock
	params    *RedisCacheMockHashSetParams
	paramPtrs *RedisCacheMockHashSetParamPtrs
	results   *RedisCacheMockHashSetResults
	Counter   uint64
}

// RedisCacheMockHashSetParams contains parameters of the RedisCache.HashSet
type RedisCacheMockHashSetParams struct {
	ctx   context.Context
	key   string
	value interface{}
}

// RedisCacheMockHashSetParamPtrs contains pointers to parameters of the RedisCache.HashSet
type RedisCacheMockHashSetParamPtrs struct {
	ctx   *context.Context
	key   *string
	value *interface{}
}

// RedisCacheMockHashSetResults contains results of the RedisCache.HashSet
type RedisCacheMockHashSetResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHashSet *mRedisCacheMockHashSet) Optional() *mRedisCacheMockHashSet {
	mmHashSet.optional = true
	return mmHashSet
}

// Expect sets up expected params for RedisCache.HashSet
func (mmHashSet *mRedisCacheMockHashSet) Expect(ctx context.Context, key string, value interface{}) *mRedisCacheMockHashSet {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("RedisCacheMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &RedisCacheMockHashSetExpectation{}
	}

	if mmHashSet.defaultExpectation.paramPtrs != nil {
		mmHashSet.mock.t.Fatalf("RedisCacheMock.HashSet mock is already set by ExpectParams functions")
	}

	mmHashSet.defaultExpectation.params = &RedisCacheMockHashSetParams{ctx, key, value}
	for _, e := range mmHashSet.expectations {
		if minimock.Equal(e.params, mmHashSet.defaultExpectation.params) {
			mmHashSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHashSet.defaultExpectation.params)
		}
	}

	return mmHashSet
}

// ExpectCtxParam1 sets up expected param ctx for RedisCache.HashSet
func (mmHashSet *mRedisCacheMockHashSet) ExpectCtxParam1(ctx context.Context) *mRedisCacheMockHashSet {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("RedisCacheMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &RedisCacheMockHashSetExpectation{}
	}

	if mmHashSet.defaultExpectation.params != nil {
		mmHashSet.mock.t.Fatalf("RedisCacheMock.HashSet mock is already set by Expect")
	}

	if mmHashSet.defaultExpectation.paramPtrs == nil {
		mmHashSet.defaultExpectation.paramPtrs = &RedisCacheMockHashSetParamPtrs{}
	}
	mmHashSet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHashSet
}

// ExpectKeyParam2 sets up expected param key for RedisCache.HashSet
func (mmHashSet *mRedisCacheMockHashSet) ExpectKeyParam2(key string) *mRedisCacheMockHashSet {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("RedisCacheMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &RedisCacheMockHashSetExpectation{}
	}

	if mmHashSet.defaultExpectation.params != nil {
		mmHashSet.mock.t.Fatalf("RedisCacheMock.HashSet mock is already set by Expect")
	}

	if mmHashSet.defaultExpectation.paramPtrs == nil {
		mmHashSet.defaultExpectation.paramPtrs = &RedisCacheMockHashSetParamPtrs{}
	}
	mmHashSet.defaultExpectation.paramPtrs.key = &key

	return mmHashSet
}

// ExpectValueParam3 sets up expected param value for RedisCache.HashSet
func (mmHashSet *mRedisCacheMockHashSet) ExpectValueParam3(value interface{}) *mRedisCacheMockHashSet {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("RedisCacheMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &RedisCacheMockHashSetExpectation{}
	}

	if mmHashSet.defaultExpectation.params != nil {
		mmHashSet.mock.t.Fatalf("RedisCacheMock.HashSet mock is already set by Expect")
	}

	if mmHashSet.defaultExpectation.paramPtrs == nil {
		mmHashSet.defaultExpectation.paramPtrs = &RedisCacheMockHashSetParamPtrs{}
	}
	mmHashSet.defaultExpectation.paramPtrs.value = &value

	return mmHashSet
}

// Inspect accepts an inspector function that has same arguments as the RedisCache.HashSet
func (mmHashSet *mRedisCacheMockHashSet) Inspect(f func(ctx context.Context, key string, value interface{})) *mRedisCacheMockHashSet {
	if mmHashSet.mock.inspectFuncHashSet != nil {
		mmHashSet.mock.t.Fatalf("Inspect function is already set for RedisCacheMock.HashSet")
	}

	mmHashSet.mock.inspectFuncHashSet = f

	return mmHashSet
}

// Return sets up results that will be returned by RedisCache.HashSet
func (mmHashSet *mRedisCacheMockHashSet) Return(err error) *RedisCacheMock {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("RedisCacheMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &RedisCacheMockHashSetExpectation{mock: mmHashSet.mock}
	}
	mmHashSet.defaultExpectation.results = &RedisCacheMockHashSetResults{err}
	return mmHashSet.mock
}

// Set uses given function f to mock the RedisCache.HashSet method
func (mmHashSet *mRedisCacheMockHashSet) Set(f func(ctx context.Context, key string, value interface{}) (err error)) *RedisCacheMock {
	if mmHashSet.defaultExpectation != nil {
		mmHashSet.mock.t.Fatalf("Default expectation is already set for the RedisCache.HashSet method")
	}

	if len(mmHashSet.expectations) > 0 {
		mmHashSet.mock.t.Fatalf("Some expectations are already set for the RedisCache.HashSet method")
	}

	mmHashSet.mock.funcHashSet = f
	return mmHashSet.mock
}

// When sets expectation for the RedisCache.HashSet which will trigger the result defined by the following
// Then helper
func (mmHashSet *mRedisCacheMockHashSet) When(ctx context.Context, key string, value interface{}) *RedisCacheMockHashSetExpectation {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("RedisCacheMock.HashSet mock is already set by Set")
	}

	expectation := &RedisCacheMockHashSetExpectation{
		mock:   mmHashSet.mock,
		params: &RedisCacheMockHashSetParams{ctx, key, value},
	}
	mmHashSet.expectations = append(mmHashSet.expectations, expectation)
	return expectation
}

// Then sets up RedisCache.HashSet return parameters for the expectation previously defined by the When method
func (e *RedisCacheMockHashSetExpectation) Then(err error) *RedisCacheMock {
	e.results = &RedisCacheMockHashSetResults{err}
	return e.mock
}

// Times sets number of times RedisCache.HashSet should be invoked
func (mmHashSet *mRedisCacheMockHashSet) Times(n uint64) *mRedisCacheMockHashSet {
	if n == 0 {
		mmHashSet.mock.t.Fatalf("Times of RedisCacheMock.HashSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHashSet.expectedInvocations, n)
	return mmHashSet
}

func (mmHashSet *mRedisCacheMockHashSet) invocationsDone() bool {
	if len(mmHashSet.expectations) == 0 && mmHashSet.defaultExpectation == nil && mmHashSet.mock.funcHashSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHashSet.mock.afterHashSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHashSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HashSet implements cache.RedisCache
func (mmHashSet *RedisCacheMock) HashSet(ctx context.Context, key string, value interface{}) (err error) {
	mm_atomic.AddUint64(&mmHashSet.beforeHashSetCounter, 1)
	defer mm_atomic.AddUint64(&mmHashSet.afterHashSetCounter, 1)

	if mmHashSet.inspectFuncHashSet != nil {
		mmHashSet.inspectFuncHashSet(ctx, key, value)
	}

	mm_params := RedisCacheMockHashSetParams{ctx, key, value}

	// Record call args
	mmHashSet.HashSetMock.mutex.Lock()
	mmHashSet.HashSetMock.callArgs = append(mmHashSet.HashSetMock.callArgs, &mm_params)
	mmHashSet.HashSetMock.mutex.Unlock()

	for _, e := range mmHashSet.HashSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHashSet.HashSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHashSet.HashSetMock.defaultExpectation.Counter, 1)
		mm_want := mmHashSet.HashSetMock.defaultExpectation.params
		mm_want_ptrs := mmHashSet.HashSetMock.defaultExpectation.paramPtrs

		mm_got := RedisCacheMockHashSetParams{ctx, key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHashSet.t.Errorf("RedisCacheMock.HashSet got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmHashSet.t.Errorf("RedisCacheMock.HashSet got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmHashSet.t.Errorf("RedisCacheMock.HashSet got unexpected parameter value, want: %#v, got: %#v%s\n", *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHashSet.t.Errorf("RedisCacheMock.HashSet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHashSet.HashSetMock.defaultExpectation.results
		if mm_results == nil {
			mmHashSet.t.Fatal("No results are set for the RedisCacheMock.HashSet")
		}
		return (*mm_results).err
	}
	if mmHashSet.funcHashSet != nil {
		return mmHashSet.funcHashSet(ctx, key, value)
	}
	mmHashSet.t.Fatalf("Unexpected call to RedisCacheMock.HashSet. %v %v %v", ctx, key, value)
	return
}

// HashSetAfterCounter returns a count of finished RedisCacheMock.HashSet invocations
func (mmHashSet *RedisCacheMock) HashSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashSet.afterHashSetCounter)
}

// HashSetBeforeCounter returns a count of RedisCacheMock.HashSet invocations
func (mmHashSet *RedisCacheMock) HashSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashSet.beforeHashSetCounter)
}

// Calls returns a list of arguments used in each call to RedisCacheMock.HashSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHashSet *mRedisCacheMockHashSet) Calls() []*RedisCacheMockHashSetParams {
	mmHashSet.mutex.RLock()

	argCopy := make([]*RedisCacheMockHashSetParams, len(mmHashSet.callArgs))
	copy(argCopy, mmHashSet.callArgs)

	mmHashSet.mutex.RUnlock()

	return argCopy
}

// MinimockHashSetDone returns true if the count of the HashSet invocations corresponds
// the number of defined expectations
func (m *RedisCacheMock) MinimockHashSetDone() bool {
	if m.HashSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HashSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HashSetMock.invocationsDone()
}

// MinimockHashSetInspect logs each unmet expectation
func (m *RedisCacheMock) MinimockHashSetInspect() {
	for _, e := range m.HashSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisCacheMock.HashSet with params: %#v", *e.params)
		}
	}

	afterHashSetCounter := mm_atomic.LoadUint64(&m.afterHashSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HashSetMock.defaultExpectation != nil && afterHashSetCounter < 1 {
		if m.HashSetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RedisCacheMock.HashSet")
		} else {
			m.t.Errorf("Expected call to RedisCacheMock.HashSet with params: %#v", *m.HashSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHashSet != nil && afterHashSetCounter < 1 {
		m.t.Error("Expected call to RedisCacheMock.HashSet")
	}

	if !m.HashSetMock.invocationsDone() && afterHashSetCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCacheMock.HashSet but found %d calls",
			mm_atomic.LoadUint64(&m.HashSetMock.expectedInvocations), afterHashSetCounter)
	}
}

type mRedisCacheMockPing struct {
	optional           bool
	mock               *RedisCacheMock
	defaultExpectation *RedisCacheMockPingExpectation
	expectations       []*RedisCacheMockPingExpectation

	callArgs []*RedisCacheMockPingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RedisCacheMockPingExpectation specifies expectation struct of the RedisCache.Ping
type RedisCacheMockPingExpectation struct {
	mock      *RedisCacheMock
	params    *RedisCacheMockPingParams
	paramPtrs *RedisCacheMockPingParamPtrs
	results   *RedisCacheMockPingResults
	Counter   uint64
}

// RedisCacheMockPingParams contains parameters of the RedisCache.Ping
type RedisCacheMockPingParams struct {
	ctx context.Context
}

// RedisCacheMockPingParamPtrs contains pointers to parameters of the RedisCache.Ping
type RedisCacheMockPingParamPtrs struct {
	ctx *context.Context
}

// RedisCacheMockPingResults contains results of the RedisCache.Ping
type RedisCacheMockPingResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPing *mRedisCacheMockPing) Optional() *mRedisCacheMockPing {
	mmPing.optional = true
	return mmPing
}

// Expect sets up expected params for RedisCache.Ping
func (mmPing *mRedisCacheMockPing) Expect(ctx context.Context) *mRedisCacheMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RedisCacheMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &RedisCacheMockPingExpectation{}
	}

	if mmPing.defaultExpectation.paramPtrs != nil {
		mmPing.mock.t.Fatalf("RedisCacheMock.Ping mock is already set by ExpectParams functions")
	}

	mmPing.defaultExpectation.params = &RedisCacheMockPingParams{ctx}
	for _, e := range mmPing.expectations {
		if minimock.Equal(e.params, mmPing.defaultExpectation.params) {
			mmPing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPing.defaultExpectation.params)
		}
	}

	return mmPing
}

// ExpectCtxParam1 sets up expected param ctx for RedisCache.Ping
func (mmPing *mRedisCacheMockPing) ExpectCtxParam1(ctx context.Context) *mRedisCacheMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RedisCacheMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &RedisCacheMockPingExpectation{}
	}

	if mmPing.defaultExpectation.params != nil {
		mmPing.mock.t.Fatalf("RedisCacheMock.Ping mock is already set by Expect")
	}

	if mmPing.defaultExpectation.paramPtrs == nil {
		mmPing.defaultExpectation.paramPtrs = &RedisCacheMockPingParamPtrs{}
	}
	mmPing.defaultExpectation.paramPtrs.ctx = &ctx

	return mmPing
}

// Inspect accepts an inspector function that has same arguments as the RedisCache.Ping
func (mmPing *mRedisCacheMockPing) Inspect(f func(ctx context.Context)) *mRedisCacheMockPing {
	if mmPing.mock.inspectFuncPing != nil {
		mmPing.mock.t.Fatalf("Inspect function is already set for RedisCacheMock.Ping")
	}

	mmPing.mock.inspectFuncPing = f

	return mmPing
}

// Return sets up results that will be returned by RedisCache.Ping
func (mmPing *mRedisCacheMockPing) Return(err error) *RedisCacheMock {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RedisCacheMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &RedisCacheMockPingExpectation{mock: mmPing.mock}
	}
	mmPing.defaultExpectation.results = &RedisCacheMockPingResults{err}
	return mmPing.mock
}

// Set uses given function f to mock the RedisCache.Ping method
func (mmPing *mRedisCacheMockPing) Set(f func(ctx context.Context) (err error)) *RedisCacheMock {
	if mmPing.defaultExpectation != nil {
		mmPing.mock.t.Fatalf("Default expectation is already set for the RedisCache.Ping method")
	}

	if len(mmPing.expectations) > 0 {
		mmPing.mock.t.Fatalf("Some expectations are already set for the RedisCache.Ping method")
	}

	mmPing.mock.funcPing = f
	return mmPing.mock
}

// When sets expectation for the RedisCache.Ping which will trigger the result defined by the following
// Then helper
func (mmPing *mRedisCacheMockPing) When(ctx context.Context) *RedisCacheMockPingExpectation {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("RedisCacheMock.Ping mock is already set by Set")
	}

	expectation := &RedisCacheMockPingExpectation{
		mock:   mmPing.mock,
		params: &RedisCacheMockPingParams{ctx},
	}
	mmPing.expectations = append(mmPing.expectations, expectation)
	return expectation
}

// Then sets up RedisCache.Ping return parameters for the expectation previously defined by the When method
func (e *RedisCacheMockPingExpectation) Then(err error) *RedisCacheMock {
	e.results = &RedisCacheMockPingResults{err}
	return e.mock
}

// Times sets number of times RedisCache.Ping should be invoked
func (mmPing *mRedisCacheMockPing) Times(n uint64) *mRedisCacheMockPing {
	if n == 0 {
		mmPing.mock.t.Fatalf("Times of RedisCacheMock.Ping mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPing.expectedInvocations, n)
	return mmPing
}

func (mmPing *mRedisCacheMockPing) invocationsDone() bool {
	if len(mmPing.expectations) == 0 && mmPing.defaultExpectation == nil && mmPing.mock.funcPing == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPing.mock.afterPingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPing.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Ping implements cache.RedisCache
func (mmPing *RedisCacheMock) Ping(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPing.beforePingCounter, 1)
	defer mm_atomic.AddUint64(&mmPing.afterPingCounter, 1)

	if mmPing.inspectFuncPing != nil {
		mmPing.inspectFuncPing(ctx)
	}

	mm_params := RedisCacheMockPingParams{ctx}

	// Record call args
	mmPing.PingMock.mutex.Lock()
	mmPing.PingMock.callArgs = append(mmPing.PingMock.callArgs, &mm_params)
	mmPing.PingMock.mutex.Unlock()

	for _, e := range mmPing.PingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPing.PingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPing.PingMock.defaultExpectation.Counter, 1)
		mm_want := mmPing.PingMock.defaultExpectation.params
		mm_want_ptrs := mmPing.PingMock.defaultExpectation.paramPtrs

		mm_got := RedisCacheMockPingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPing.t.Errorf("RedisCacheMock.Ping got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPing.t.Errorf("RedisCacheMock.Ping got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPing.PingMock.defaultExpectation.results
		if mm_results == nil {
			mmPing.t.Fatal("No results are set for the RedisCacheMock.Ping")
		}
		return (*mm_results).err
	}
	if mmPing.funcPing != nil {
		return mmPing.funcPing(ctx)
	}
	mmPing.t.Fatalf("Unexpected call to RedisCacheMock.Ping. %v", ctx)
	return
}

// PingAfterCounter returns a count of finished RedisCacheMock.Ping invocations
func (mmPing *RedisCacheMock) PingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.afterPingCounter)
}

// PingBeforeCounter returns a count of RedisCacheMock.Ping invocations
func (mmPing *RedisCacheMock) PingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.beforePingCounter)
}

// Calls returns a list of arguments used in each call to RedisCacheMock.Ping.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPing *mRedisCacheMockPing) Calls() []*RedisCacheMockPingParams {
	mmPing.mutex.RLock()

	argCopy := make([]*RedisCacheMockPingParams, len(mmPing.callArgs))
	copy(argCopy, mmPing.callArgs)

	mmPing.mutex.RUnlock()

	return argCopy
}

// MinimockPingDone returns true if the count of the Ping invocations corresponds
// the number of defined expectations
func (m *RedisCacheMock) MinimockPingDone() bool {
	if m.PingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PingMock.invocationsDone()
}

// MinimockPingInspect logs each unmet expectation
func (m *RedisCacheMock) MinimockPingInspect() {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisCacheMock.Ping with params: %#v", *e.params)
		}
	}

	afterPingCounter := mm_atomic.LoadUint64(&m.afterPingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && afterPingCounter < 1 {
		if m.PingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RedisCacheMock.Ping")
		} else {
			m.t.Errorf("Expected call to RedisCacheMock.Ping with params: %#v", *m.PingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && afterPingCounter < 1 {
		m.t.Error("Expected call to RedisCacheMock.Ping")
	}

	if !m.PingMock.invocationsDone() && afterPingCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCacheMock.Ping but found %d calls",
			mm_atomic.LoadUint64(&m.PingMock.expectedInvocations), afterPingCounter)
	}
}

type mRedisCacheMockSet struct {
	optional           bool
	mock               *RedisCacheMock
	defaultExpectation *RedisCacheMockSetExpectation
	expectations       []*RedisCacheMockSetExpectation

	callArgs []*RedisCacheMockSetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RedisCacheMockSetExpectation specifies expectation struct of the RedisCache.Set
type RedisCacheMockSetExpectation struct {
	mock      *RedisCacheMock
	params    *RedisCacheMockSetParams
	paramPtrs *RedisCacheMockSetParamPtrs
	results   *RedisCacheMockSetResults
	Counter   uint64
}

// RedisCacheMockSetParams contains parameters of the RedisCache.Set
type RedisCacheMockSetParams struct {
	ctx   context.Context
	key   string
	value interface{}
}

// RedisCacheMockSetParamPtrs contains pointers to parameters of the RedisCache.Set
type RedisCacheMockSetParamPtrs struct {
	ctx   *context.Context
	key   *string
	value *interface{}
}

// RedisCacheMockSetResults contains results of the RedisCache.Set
type RedisCacheMockSetResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mRedisCacheMockSet) Optional() *mRedisCacheMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for RedisCache.Set
func (mmSet *mRedisCacheMockSet) Expect(ctx context.Context, key string, value interface{}) *mRedisCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisCacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisCacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("RedisCacheMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &RedisCacheMockSetParams{ctx, key, value}
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectCtxParam1 sets up expected param ctx for RedisCache.Set
func (mmSet *mRedisCacheMockSet) ExpectCtxParam1(ctx context.Context) *mRedisCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisCacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisCacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RedisCacheMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RedisCacheMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSet
}

// ExpectKeyParam2 sets up expected param key for RedisCache.Set
func (mmSet *mRedisCacheMockSet) ExpectKeyParam2(key string) *mRedisCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisCacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisCacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RedisCacheMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RedisCacheMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.key = &key

	return mmSet
}

// ExpectValueParam3 sets up expected param value for RedisCache.Set
func (mmSet *mRedisCacheMockSet) ExpectValueParam3(value interface{}) *mRedisCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisCacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisCacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("RedisCacheMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &RedisCacheMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.value = &value

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the RedisCache.Set
func (mmSet *mRedisCacheMockSet) Inspect(f func(ctx context.Context, key string, value interface{})) *mRedisCacheMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for RedisCacheMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by RedisCache.Set
func (mmSet *mRedisCacheMockSet) Return(err error) *RedisCacheMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisCacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &RedisCacheMockSetExpectation{mock: mmSet.mock}
	}
	mmSet.defaultExpectation.results = &RedisCacheMockSetResults{err}
	return mmSet.mock
}

// Set uses given function f to mock the RedisCache.Set method
func (mmSet *mRedisCacheMockSet) Set(f func(ctx context.Context, key string, value interface{}) (err error)) *RedisCacheMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the RedisCache.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the RedisCache.Set method")
	}

	mmSet.mock.funcSet = f
	return mmSet.mock
}

// When sets expectation for the RedisCache.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mRedisCacheMockSet) When(ctx context.Context, key string, value interface{}) *RedisCacheMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("RedisCacheMock.Set mock is already set by Set")
	}

	expectation := &RedisCacheMockSetExpectation{
		mock:   mmSet.mock,
		params: &RedisCacheMockSetParams{ctx, key, value},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up RedisCache.Set return parameters for the expectation previously defined by the When method
func (e *RedisCacheMockSetExpectation) Then(err error) *RedisCacheMock {
	e.results = &RedisCacheMockSetResults{err}
	return e.mock
}

// Times sets number of times RedisCache.Set should be invoked
func (mmSet *mRedisCacheMockSet) Times(n uint64) *mRedisCacheMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of RedisCacheMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	return mmSet
}

func (mmSet *mRedisCacheMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements cache.RedisCache
func (mmSet *RedisCacheMock) Set(ctx context.Context, key string, value interface{}) (err error) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, key, value)
	}

	mm_params := RedisCacheMockSetParams{ctx, key, value}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := RedisCacheMockSetParams{ctx, key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSet.t.Errorf("RedisCacheMock.Set got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSet.t.Errorf("RedisCacheMock.Set got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSet.t.Errorf("RedisCacheMock.Set got unexpected parameter value, want: %#v, got: %#v%s\n", *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("RedisCacheMock.Set got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSet.SetMock.defaultExpectation.results
		if mm_results == nil {
			mmSet.t.Fatal("No results are set for the RedisCacheMock.Set")
		}
		return (*mm_results).err
	}
	if mmSet.funcSet != nil {
		return mmSet.funcSet(ctx, key, value)
	}
	mmSet.t.Fatalf("Unexpected call to RedisCacheMock.Set. %v %v %v", ctx, key, value)
	return
}

// SetAfterCounter returns a count of finished RedisCacheMock.Set invocations
func (mmSet *RedisCacheMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of RedisCacheMock.Set invocations
func (mmSet *RedisCacheMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to RedisCacheMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mRedisCacheMockSet) Calls() []*RedisCacheMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*RedisCacheMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *RedisCacheMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *RedisCacheMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RedisCacheMock.Set with params: %#v", *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RedisCacheMock.Set")
		} else {
			m.t.Errorf("Expected call to RedisCacheMock.Set with params: %#v", *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Error("Expected call to RedisCacheMock.Set")
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to RedisCacheMock.Set but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), afterSetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RedisCacheMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockExpireInspect()

			m.MinimockGetInspect()

			m.MinimockHGetAllInspect()

			m.MinimockHashSetInspect()

			m.MinimockPingInspect()

			m.MinimockSetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RedisCacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RedisCacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExpireDone() &&
		m.MinimockGetDone() &&
		m.MinimockHGetAllDone() &&
		m.MinimockHashSetDone() &&
		m.MinimockPingDone() &&
		m.MinimockSetDone()
}
